-- Full main script (Rayfield + Modifiers, ESP, Spin + Kamikaze Fling)
-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local LocalPlayer = Players.LocalPlayer

-- Try multiple Rayfield loader URLs so GUI is more robust
local rayfieldSources = {
    "https://sirius.menu/rayfield",                                 -- your original
    "https://raw.githubusercontent.com/shlexware/Rayfield/main/source" -- fallback
}
local Rayfield
for _, url in ipairs(rayfieldSources) do
    local ok, res = pcall(function()
        return loadstring(game:HttpGet(url, true))()
    end)
    if ok and res then
        Rayfield = res
        break
    end
end
if not Rayfield then
    warn("Failed to load Rayfield from known sources.")
    return
end

-- Create Window
local Window = Rayfield:CreateWindow({
    Name = "Mod Menu",
    LoadingTitle = "Mod Menu",
    LoadingSubtitle = "By YourNightMare",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "RayfieldConfigs",
        FileName = "FourTabUI"
    }
})

-- helper: smooth slider fill tween (defensive)
local function updateSliderFillSmooth(sliderObj, fraction)
    if not sliderObj then return end
    pcall(function()
        if sliderObj.SliderFill then
            local tweenInfo = TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            TweenService:Create(sliderObj.SliderFill, tweenInfo, {Size = UDim2.new(math.clamp(fraction, 0, 1), 0, 1, 0)}):Play()
        end
    end)
end

-- state
local prevToggles = {
    Flight=false, NoClip=false, Spin=false, Godmode=false, Fling=false,
    HitboxESP=false, NameESP=false, HealthESP=false, DistanceESP=false, InfiniteJump=false
}
local movementValues = {WalkSpeed=16, JumpHeight=7, FlingStrength=1e9}

-------------------------
-- TAB 1: Modifiers
-------------------------
local ModifiersTab = Window:CreateTab("Modifiers", 4483362458)

ModifiersTab:CreateSlider({
    Name="WalkSpeed", Range={16,100}, Increment=1, CurrentValue=movementValues.WalkSpeed,
    Flag="WalkSpeed",
    Callback=function(Value)
        movementValues.WalkSpeed = Value
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then pcall(function() hum.WalkSpeed = math.clamp(Value,16,100) end) end
        local sliderObj = ModifiersTab.Flags and ModifiersTab.Flags["WalkSpeed"] and ModifiersTab.Flags["WalkSpeed"].Object
        updateSliderFillSmooth(sliderObj, (Value-16)/(100-16))
    end
})

ModifiersTab:CreateSlider({
    Name="Jump Height", Range={7,50}, Increment=1, CurrentValue=movementValues.JumpHeight,
    Flag="JumpHeight",
    Callback=function(Value)
        movementValues.JumpHeight = Value
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then
            pcall(function()
                hum.UseJumpPower = false
                hum.JumpHeight = math.clamp(Value,7,50)
            end)
        end
        local sliderObj = ModifiersTab.Flags and ModifiersTab.Flags["JumpHeight"] and ModifiersTab.Flags["JumpHeight"].Object
        updateSliderFillSmooth(sliderObj, (Value-7)/(50-7))
    end
})

-- Flight
local flying, flySpeed = false, 50
local bodyVel = nil
local function startFlight()
    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    if bodyVel then pcall(function() bodyVel:Destroy() end) end
    bodyVel = Instance.new("BodyVelocity")
    bodyVel.MaxForce = Vector3.new(4e4,4e4,4e4)
    bodyVel.Velocity = Vector3.zero
    bodyVel.Parent = root
    while flying and task.wait(0.02) do
        local moveDir = Vector3.zero
        local cam = workspace.CurrentCamera
        if cam then
            if UIS:IsKeyDown(Enum.KeyCode.W) then moveDir += cam.CFrame.LookVector end
            if UIS:IsKeyDown(Enum.KeyCode.S) then moveDir -= cam.CFrame.LookVector end
            if UIS:IsKeyDown(Enum.KeyCode.A) then moveDir -= cam.CFrame.RightVector end
            if UIS:IsKeyDown(Enum.KeyCode.D) then moveDir += cam.CFrame.RightVector end
            if UIS:IsKeyDown(Enum.KeyCode.Space) then moveDir += Vector3.new(0,1,0) end
            if UIS:IsKeyDown(Enum.KeyCode.LeftShift) then moveDir -= Vector3.new(0,1,0) end
        end
        pcall(function() bodyVel.Velocity = (moveDir.Magnitude>0 and moveDir.Unit*math.clamp(flySpeed,10,100)) or Vector3.zero end)
    end
    if bodyVel then pcall(function() bodyVel:Destroy() end) bodyVel=nil end
end

ModifiersTab:CreateToggle({
    Name="Flight", CurrentValue=false,
    Callback=function(Value) flying = Value prevToggles.Flight = Value if flying then task.spawn(startFlight) end end
})
ModifiersTab:CreateSlider({
    Name="Flight Speed", Range={10,100}, Increment=5, CurrentValue=flySpeed,
    Callback=function(Value) flySpeed = math.clamp(Value,10,100) local sliderObj = ModifiersTab.Flags and ModifiersTab.Flags["FlightSpeed"] and ModifiersTab.Flags["FlightSpeed"].Object updateSliderFillSmooth(sliderObj, (Value-10)/(100-10)) end
})

-- NoClip
local noclip=false
local noclipConn
local noclipParts = {}
local function enableNoClip()
    local char = LocalPlayer.Character
    if not char then return end
    noclipParts = {}
    for _, p in pairs(char:GetDescendants()) do
        if p:IsA("BasePart") then
            table.insert(noclipParts, p)
            pcall(function() p.CanCollide = false end)
        end
    end
    if noclipConn then pcall(function() noclipConn:Disconnect() end) end
    noclipConn = RunService.Heartbeat:Connect(function()
        for _, p in pairs(noclipParts) do
            if p and p.Parent then pcall(function() p.CanCollide = false end) end
        end
    end)
end
local function disableNoClip()
    if noclipConn then pcall(function() noclipConn:Disconnect() end) noclipConn = nil end
    for _, p in pairs(noclipParts) do if p then pcall(function() p.CanCollide = true end) end end
    noclipParts = {}
end
ModifiersTab:CreateToggle({
    Name="NoClip", CurrentValue=false,
    Callback=function(Value) noclip = Value prevToggles.NoClip = Value if noclip then enableNoClip() else disableNoClip() end end
})

-- Infinite Jump
local infiniteJumpEnabled = false
local jumpBoost = 50
ModifiersTab:CreateToggle({Name="Infinite Jump", CurrentValue=false, Callback=function(Value) infiniteJumpEnabled = Value prevToggles.InfiniteJump = Value end})
ModifiersTab:CreateSlider({
    Name="Infinite Jump Power", Range={20,100}, Increment=5, CurrentValue=jumpBoost,
    Callback=function(Value) jumpBoost = math.clamp(Value,20,100) local sliderObj = ModifiersTab.Flags and ModifiersTab.Flags["InfiniteJumpPower"] and ModifiersTab.Flags["InfiniteJumpPower"].Object updateSliderFillSmooth(sliderObj, (Value-20)/(100-20)) end
})
UIS.JumpRequest:Connect(function()
    if infiniteJumpEnabled then
        local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if root then pcall(function() root.Velocity = Vector3.new(root.Velocity.X, jumpBoost, root.Velocity.Z) end) end
    end
end)

-------------------------
-- TAB 2: ESP
-------------------------
local ESPTab = Window:CreateTab("ESP", 4483362458)
local espObjects = {}
local hitboxESPEnabled, nameESPEnabled, healthESPEnabled, distanceESPEnabled = false,false,false,false

local function createESP(player)
    if player == LocalPlayer or not player.Character or not player.Character:FindFirstChild("Head") then return end
    local char, head = player.Character, player.Character.Head
    if not espObjects[player.Name] then
        local highlight = Instance.new("Highlight")
        highlight.FillTransparency = 1
        highlight.OutlineTransparency = hitboxESPEnabled and 0 or 1
        highlight.OutlineColor = Color3.new(0.8, 0.8, 0.8)
        highlight.Parent = char

        local billboard = Instance.new("BillboardGui")
        billboard.Size = UDim2.new(0,200,0,60)
        billboard.StudsOffset = Vector3.new(0,3,0)
        billboard.AlwaysOnTop = true
        billboard.Adornee = head
        billboard.Parent = head

        local nameLabel = Instance.new("TextLabel")
        nameLabel.Size = UDim2.new(1,0,0.33,0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.TextColor3 = Color3.new(0.8,0.8,0.8)
        nameLabel.TextScaled = true
        nameLabel.Visible = nameESPEnabled
        nameLabel.Text = player.Name
        nameLabel.Parent = billboard

        local healthLabel = Instance.new("TextLabel")
        healthLabel.Size = UDim2.new(1,0,0.33,0)
        healthLabel.Position = UDim2.new(0,0,0.33,0)
        healthLabel.BackgroundTransparency = 1
        healthLabel.TextColor3 = Color3.new(0.8,0,0)
        healthLabel.TextScaled = true
        healthLabel.Visible = healthESPEnabled
        healthLabel.Text = "HP:" .. (char:FindFirstChildOfClass("Humanoid") and math.floor(char:FindFirstChildOfClass("Humanoid").Health) or 0)
        healthLabel.Parent = billboard

        local distanceLabel = Instance.new("TextLabel")
        distanceLabel.Size = UDim2.new(1,0,0.33,0)
        distanceLabel.Position = UDim2.new(0,0,0.66,0)
        distanceLabel.BackgroundTransparency = 1
        distanceLabel.TextColor3 = Color3.new(0,0.8,0)
        distanceLabel.TextScaled = true
        distanceLabel.Visible = distanceESPEnabled
        distanceLabel.Text = LocalPlayer.Character and "Dist:" .. math.floor((head.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude) or "Dist:N/A"
        distanceLabel.Parent = billboard

        espObjects[player.Name] = {Highlight = highlight, Name = nameLabel, Health = healthLabel, Distance = distanceLabel}
    end
end

local function updateESP()
    for _, player in pairs(Players:GetPlayers()) do
        pcall(function()
            createESP(player)
            if espObjects[player.Name] and player.Character then
                local data = espObjects[player.Name]
                data.Highlight.OutlineTransparency = hitboxESPEnabled and 0 or 1
                data.Name.Visible = nameESPEnabled
                data.Health.Visible = healthESPEnabled
                data.Distance.Visible = distanceESPEnabled
                if healthESPEnabled and player.Character:FindFirstChildOfClass("Humanoid") then
                    data.Health.Text = "HP:" .. math.floor(player.Character:FindFirstChildOfClass("Humanoid").Health)
                end
                if distanceESPEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (player.Character.Head.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    data.Distance.Text = "Dist:" .. math.floor(dist)
                end
            end
        end)
    end
end

ESPTab:CreateToggle({Name="Outline ESP", CurrentValue=false, Callback=function(Value) hitboxESPEnabled=Value prevToggles.HitboxESP=Value updateESP() end})
ESPTab:CreateToggle({Name="Name ESP", CurrentValue=false, Callback=function(Value) nameESPEnabled=Value prevToggles.NameESP=Value updateESP() end})
ESPTab:CreateToggle({Name="Health ESP", CurrentValue=false, Callback=function(Value) healthESPEnabled=Value prevToggles.HealthESP=Value updateESP() end})
ESPTab:CreateToggle({Name="Distance ESP", CurrentValue=false, Callback=function(Value) distanceESPEnabled=Value prevToggles.DistanceESP=Value updateESP() end})

RunService.Heartbeat:Connect(updateESP)
Players.PlayerAdded:Connect(function(plr) plr.CharacterAdded:Connect(function() task.wait(1) updateESP() end) end)
Players.PlayerRemoving:Connect(function(player) espObjects[player.Name] = nil end)

-------------------------
-- TAB 3: Spin & Kamikaze Fling (Fling dropdown DOES NOT SAVE)
-------------------------
local SpinTab = Window:CreateTab("Spin & Fling", 4483362458)

local spinEnabled = false
local spinSpeed = 6000
local godmodeEnabled = false
local FlingActive = false
local SelectedTargets = {}
local flingLoop = nil

-- Spin toggle + slider
SpinTab:CreateToggle({Name="Spin", CurrentValue=false, Callback=function(Value) spinEnabled=Value prevToggles.Spin=Value end})
SpinTab:CreateSlider({
    Name="Spin Speed", Range={1000,12000}, Increment=500, CurrentValue=spinSpeed, Flag="SpinSpeed",
    Callback=function(Value)
        spinSpeed = Value
        local sliderObj = SpinTab.Flags and SpinTab.Flags["SpinSpeed"] and SpinTab.Flags["SpinSpeed"].Object
        updateSliderFillSmooth(sliderObj, (Value-1000)/(12000-1000))
    end
})

-- Godmode
SpinTab:CreateToggle({
    Name="Godmode", CurrentValue=false,
    Callback=function(Value)
        godmodeEnabled = Value
        prevToggles.Godmode = Value
        if godmodeEnabled then
            local char = LocalPlayer.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    hum.MaxHealth = math.huge
                    hum.Health = hum.MaxHealth
                    -- keep health topped off
                    hum.HealthChanged:Connect(function()
                        if hum and hum.Health < hum.MaxHealth then
                            pcall(function() hum.Health = hum.MaxHealth end)
                        end
                    end)
                end
            end
        end
    end
})

-- Dropdown helper (no Flag so Rayfield won't persist this selection)
local function getPlayerList()
    local list = {}
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then table.insert(list, plr.Name) end
    end
    table.sort(list)
    return list
end

local flingDropdown
-- create dropdown (CurrentOption={} so nothing starts selected)
do
    local ok, obj = pcall(function()
        return SpinTab:CreateDropdown({
            Name = "Select Fling Targets",
            Options = getPlayerList(),
            CurrentOption = {},
            MultipleOptions = true,
            -- no Flag -> Rayfield won't save
            Callback = function(selected)
                SelectedTargets = {}
                for _, name in pairs(selected) do
                    local plr = Players:FindFirstChild(name)
                    if plr then table.insert(SelectedTargets, plr) end
                end
            end
        })
    end)
    if ok then flingDropdown = obj end
end

-- safe dropdown refresh function
local function refreshDropdown()
    local options = getPlayerList()
    pcall(function()
        if flingDropdown and type(flingDropdown.Refresh) == "function" then
            flingDropdown:Refresh(options)
        elseif flingDropdown and flingDropdown.Options ~= nil then
            -- try set field if available
            flingDropdown.Options = options
        end
    end)
end

-- remove departed players from SelectedTargets so no stale references
Players.PlayerRemoving:Connect(function(plr)
    -- remove from SelectedTargets array
    for i = #SelectedTargets, 1, -1 do
        if SelectedTargets[i] == plr then table.remove(SelectedTargets, i) end
    end
    -- refresh dropdown options
    refreshDropdown()
end)

Players.PlayerAdded:Connect(function()
    -- small delay then refresh
    task.wait(0.2)
    refreshDropdown()
end)

-- Kamikaze fling implementation (defensive)
local function KamikazeFling(target)
    local Character = LocalPlayer.Character
    if not Character then return end
    local hrp = Character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        local hum = Character:FindFirstChildOfClass("Humanoid")
        hrp = hum and hum.RootPart or nil
    end
    local TChar = target and target.Character
    local TRoot = TChar and TChar:FindFirstChild("HumanoidRootPart")
    if not (hrp and TRoot) then return end

    pcall(function()
        -- teleport slightly inside/above target to trigger fling behavior
        hrp.CFrame = TRoot.CFrame + Vector3.new(0, 0.5, 0)

        -- push outward with BodyVelocity
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        local direction = (hrp.Position - TRoot.Position)
        if direction.Magnitude <= 0 then direction = Vector3.new(0,1,0) end
        bv.Velocity = direction.Unit * (movementValues.FlingStrength or 1e9)
        bv.P = 1e5
        bv.Parent = hrp
        Debris:AddItem(bv, 0.12)
    end)
end

-- helper to count selected targets
local function CountSelectedTargets()
    local count = 0
    for _, v in ipairs(SelectedTargets) do
        if v and v.Parent then count = count + 1 end
    end
    return count
end

-- Fling toggle (Kamikaze behavior) — replaces old fling
SpinTab:CreateToggle({
    Name = "Fling",
    CurrentValue = false,
    Callback = function(Value)
        FlingActive = Value
        prevToggles.Fling = Value

        if FlingActive then
            if CountSelectedTargets() == 0 then
                FlingActive = false
                Rayfield:Notify({Title = "Error", Content = "No targets selected!", Duration = 2})
                -- try to uncheck toggle UI safely (some Rayfield versions expose Flags)
                pcall(function() if SpinTab.Flags and SpinTab.Flags["Fling"] and SpinTab.Flags["Fling"].Object then SpinTab.Flags["Fling"].Object:Set(false) end end)
                return
            end

            Rayfield:Notify({Title="Fling Started", Content="Kamikaze flinging "..CountSelectedTargets().." target(s)", Duration=2})

            flingLoop = RunService.Heartbeat:Connect(function(delta)
                local char = LocalPlayer.Character
                if not char or not char:FindFirstChild("HumanoidRootPart") then return end
                local hrp = char:FindFirstChild("HumanoidRootPart")
                -- spin while flinging (if enabled)
                if spinEnabled and hrp then
                    hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(spinSpeed * delta), 0)
                end

                -- attempt to Kamikaze each target
                for i = #SelectedTargets, 1, -1 do
                    local target = SelectedTargets[i]
                    if target and target.Parent and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                        KamikazeFling(target)
                        task.wait(0.06) -- tiny pause to let physics act
                    else
                        -- remove invalid targets
                        table.remove(SelectedTargets, i)
                    end
                end

                -- if nothing left, stop
                if CountSelectedTargets() == 0 then
                    FlingActive = false
                    if flingLoop then flingLoop:Disconnect() flingLoop = nil end
                    Rayfield:Notify({Title="Fling Stopped", Content="No valid targets left", Duration=2})
                end
            end)
        else
            if flingLoop then flingLoop:Disconnect() flingLoop = nil end
            Rayfield:Notify({Title="Fling Stopped", Content="Kamikaze fling stopped", Duration=2})
        end
    end
})

-- Apply settings on respawn
LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.8)
    pcall(function()
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            hum.WalkSpeed = movementValues.WalkSpeed
            hum.UseJumpPower = false
            hum.JumpHeight = movementValues.JumpHeight
        end
        if prevToggles.Flight then flying = true task.spawn(startFlight) end
        if prevToggles.NoClip then enableNoClip() end
        infiniteJumpEnabled = prevToggles.InfiniteJump
    end)
end)

-- Final refresh & notify
refreshDropdown()
Rayfield:Notify({Title="Loaded", Content="Mod Menu loaded (Kamikaze Fling active)", Duration=3})
